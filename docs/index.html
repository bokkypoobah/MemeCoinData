<!DOCTYPE html>
<html lang="en">
  <head>
    <title>My NFTs</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
    <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
    <meta name="description" content="My NFTs (c) Bok Consulting Pty Ltd 2023" />
    <meta name="author" content="BokkyPooBah" />
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@BokkyPooBah" />
    <meta name="twitter:creator" content="@BokkyPooBah" />
    <link type="text/css" rel="stylesheet" href="css/bootstrap.min.css" />
    <link type="text/css" rel="stylesheet" href="css/bootstrap-vue.min.css"/>
    <link type="text/css" rel="stylesheet" href="css/bootstrap-vue-icons.min.css"/>
    <link type="text/css" rel="stylesheet" href="css/app.css" />
    <script src="js/vue.js"></script>
    <script src="js/bootstrap-vue.min.js"></script>
    <script src="js/bootstrap-vue-icons.min.js"></script>
    <script src="js/ethers-5.6.umd.min.js" type="application/javascript"></script>
    <script src="js/moment.min.js"></script>
    <script src="js/dexie.js"></script>
    <script src="globals.js"></script>
    <script src="deploymentData.js"></script>
    <script src="txparser.js"></script>

    <link rel="apple-touch-icon" sizes="57x57" href="images/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="images/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="images/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="images/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="images/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="images/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="images/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="images/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="images/apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192"  href="images/android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="images/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="images/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="images/favicon-16x16.png">
    <link rel="manifest" href="images/manifest.json">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-TileImage" content="images/ms-icon-144x144.png">
    <meta name="theme-color" content="#ffffff">
  </head>
  <body>
    <div id="app">
      <b-container fluid class="m-0 p-0">
        <b-navbar toggleable="sm" variant="light" class="mx-1 my-0 p-0">
          <b-navbar-brand to="/" variant="primary">
            <b-avatar rounded variant="light" size="3.0rem" src="images/ZombieBaby_001_gp2_3871_8601_10786.gif" v-b-popover.hover.bottom="'gm'" class="ml-0"></b-avatar>
            <em v-b-popover.hover.bottom="'gm gm gm'">My NFTs</em>
          </b-navbar-brand>
          <b-navbar-nav class="ml-auto">
            <b-nav-item size="sm" @click="settings.tabIndex = 0; saveSettings()" :active="settings.tabIndex == 0" active-class="active" v-b-popover.hover="'View NFTs'">NFTs</b-nav-item>
            <!-- <b-nav-item size="sm" @click="settings.tabIndex = 1; saveSettings()" :active="settings.tabIndex == 1" active-class="active" v-b-popover.hover="'View collections'">Collections</b-nav-item> -->
            <b-nav-item size="sm" @click="settings.tabIndex = 2; saveSettings()" :active="settings.tabIndex == 2" active-class="active" v-b-popover.hover="'View/edit accounts'">Accounts</b-nav-item>
            <!-- <b-avatar v-if="coinbase && coinbase != ensOrAddress(coinbase)" rounded variant="light" size="2.0rem" :src="'https://metadata.ens.domains/mainnet/avatar/' + ensOrAddress(coinbase)" v-b-popover.hover="'Your ENS avatar if set'"></b-avatar>
            <b-button size="sm" variant="primary" class="ml-1" @click="processIt('connect')" v-b-popover.hover.bottom="'Click to update wallet'">{{ coinbase ? ensOrAddress(coinbase, 32) : 'Connect' }}</b-button> -->
          </b-navbar-nav>
        </b-navbar>

        <b-card no-body class="p-0 mt-0" style="min-height: 666px;">
          <b-alert v-if="false" size="sm" dismissible variant="warning" show class="m-1 my-0">
            Warning: This is experimental unaudited software. Revoke permissions when not required, at this early stage.
          </b-alert>
          <b-card v-if="false" class="m-2 p-1" header-class="warningheader" header="Welcome" v-if="!coinbase">
            <b-card-text>
              Please install the MetaMask extension, connect to the Ethereum mainnet and refresh this page. Then click the [Connect] button on the top right.
            </b-card-text>
          </b-card>

          <b-modal id="modal-token" hide-footer size="lg">
            <template #modal-title>
              <font size="-1">{{ modalToken.token && modalToken.token.name }}</font>
              <!--
              <b-button size="sm" @click="copyToClipboard(modalTx.hash);" variant="link" class="m-0 p-0" v-b-popover.hover.top="'Copy to clipboard'"><b-icon-clipboard shift-v="+1" font-scale="1.1"></b-icon-clipboard></b-button>
              <b-button size="sm" :href="'https://etherscan.io/tx/' + modalTx.hash" target="_blank" variant="link" class="m-0 p-0" v-b-popover.hover.top="'View in etherscan.io'">
                <b-img rounded="0" width="16px" height="16px" src="images/etherscan-logo-circle.svg" blank-color="#777" target="_blank"></b-img>
              </b-button>
              -->
            </template>
            <div class="d-flex flex-row">
              <div>
                <b-avatar v-if="modalToken.token" rounded variant="light" size="8.0rem" :src="modalToken.token.image">
                </b-avatar>
              </div>
              <div class="ml-2">
                {{ modalToken.token && modalToken.token.name }}
                <br />
                {{ modalToken.token && modalToken.token.collectionName }}
                <br />
                {{ modalToken.token && modalToken.token.tokenId }}
                <b-button v-if="modalToken.token" size="sm" :href="'https://opensea.io/assets/ethereum/' + modalToken.token.contract + '/' + modalToken.token.tokenId" target="_blank" variant="link" v-b-popover.hover.top="'View token in opensea.io'">
                  <b-avatar rounded variant="light" size="0.9rem" src="images/opensea.svg">
                  </b-avatar>
                </b-button>
                <b-button v-if="modalToken.token" size="sm" :href="'https://etherscan.io/token/' + modalToken.token.contract + ((modalToken.token.kind == 'erc721' || modalToken.token.kind== 'erc1155') ? ('?a=' + modalToken.token.tokenId) : '')" target="_blank" variant="link" v-b-popover.hover.top="'View token in etherscan.io'">
                  <b-avatar rounded variant="light" size="0.9rem" src="images/etherscan-logo-circle.svg">
                  </b-avatar>
                </b-button>
                <br />
                {{ modalToken.token && modalToken.token.ownerName }}
                <b-button v-if="modalToken.token" size="sm" :href="'https://opensea.io/' + modalToken.token.owner" target="_blank" variant="link" v-b-popover.hover.top="'View owner account in opensea.io'">
                  <b-avatar rounded variant="light" size="0.9rem" src="images/opensea.svg">
                  </b-avatar>
                </b-button>
                <br />
                <b-button size="sm" @click="requestReservoirAPITokenMetadataRefresh(modalToken.token)" variant="link" v-b-popover.hover.top="'Request a metadata refresh on the Reservoir API. Re-sync after a few minutes'"><b-icon-arrow-clockwise shift-v="+1" font-scale="1.2"></b-icon-arrow-clockwise></b-button>
              </div>
            </div>
          </b-modal>

          <b-modal id="modal-accounts-import" hide-footer size="lg">
            <template #modal-title>
              Import Accounts
            </template>
            <b-form-group label="Restore:" label-for="restore-from-backup-browse" label-size="sm" label-cols-sm="2" label-align-sm="right" :description="'Select backup .tsv file from your local computer to restore'" class="mx-0 my-1 p-0">
              <b-form-file size="sm" id="restore-from-backup-browse" v-model="restoreFile" @change="backupFilesChange($event.target.name, $event.target.files)" accept=".tsv" class="w-75"></b-form-file>
            </b-form-group>
            <b-form-group v-if="restoreAddresses" label="Loaded data:" label-for="restore-from-backup-data" label-size="sm" label-cols-sm="2" label-align-sm="right" :description="'Only valid unique addresses will be imported'" class="mx-0 my-1 p-0">
              <font v-if="restoreAddresses" size="-2">
                <b-table small id="restore-from-backup-data" fixed striped sticky-header="200px" :fields="accountsImportAddressesFields" :items="restoreAddresses" head-variant="light">
                </b-table>
              </font>
            </b-form-group>
            <b-form-group label="" label-for="restore-from-backup" label-size="sm" label-cols-sm="2" label-align-sm="right" :description="'Restore from backup file. Adjust Sync and Include settings and re-synced'" class="mx-0 my-1 p-0">
              <b-button size="sm" id="restore-from-backup" :disabled="!restoreAddresses || restoreAddresses.length == 0" @click="restoreFromBackup()" variant="primary">Restore</b-button>
            </b-form-group>
          </b-modal>

          <b-card v-if="settings.tabIndex == 0" class="m-0 p-0 border-0" body-class="m-1 p-0" header-class="m-0 p-2">
            <div class="d-flex flex-wrap m-0 p-0">
              <div class="mt-0 pr-1">
                <b-form-input type="text" size="sm" v-model.trim="settings.tokensTable.tokenFilter" @change="saveSettings" debounce="600" v-b-popover.hover.top="'Token id and name filter'" placeholder="ðŸ” token id/name regex" style="min-width: 8.0rem;"></b-form-input>
              </div>
              <div class="mt-0 pr-1">
                <b-form-input type="text" size="sm" v-model.trim="settings.tokensTable.collectionfilter" @change="saveSettings" debounce="600" v-b-popover.hover.top="'Collection name filter'" placeholder="ðŸ” collection name" style="min-width: 8.0rem;"></b-form-input>
              </div>
              <div class="mt-0 pr-1">
                <b-button size="sm" :pressed.sync="settings.showAdditionalFilters" @click="saveSettings" variant="link" v-b-popover.hover.top="'Additional filters'"><span v-if="settings.showAdditionalFilters"><b-icon-funnel-fill shift-v="+1" font-scale="1.0"></b-icon-funnel-fill></span><span v-else><b-icon-funnel shift-v="+1" font-scale="1.0"></b-icon-funnel></span></b-button>
              </div>
              <div v-if="Object.keys(settings.filters).length > 0" class="mt-0 pr-1">
                <b-button size="sm" @click="resetAdditionalFilters();" variant="link" class="m-0 p-0" v-b-popover.hover.top="'Reset additional filters'">
                  <b-iconstack shift-v="-1" font-scale="1">
                    <b-icon stacked icon="funnel-fill" variant="info" scale="1"></b-icon>
                    <b-icon stacked icon="x" variant="danger" scale="1.3"></b-icon>
                  </b-iconstack>
                </b-button>
              </div>
              <div class="mt-0 flex-grow-1">
              </div>
              <div class="mt-0 flex-grow-1">
              </div>
              <div v-if="!sync.section" class="mt-0 pr-1">
                <b-button size="sm" @click="syncAccounts()" variant="primary" v-b-popover.hover.top="'Select NFT collections to for accounts'">Sync</b-button>
              </div>
              <div class="mt-1" style="width: 200px;">
                <b-progress v-if="sync.section != null" height="1.5rem" :max="sync.total" show-progress :animated="sync.section != null" :variant="sync.section != null ? 'success' : 'secondary'" v-b-popover.hover.top="'Click the button on the right to stop. This process can be continued later'">
                  <b-progress-bar :value="sync.completed">
                    {{ sync.total == null ? (sync.completed + ' ' + sync.section) : (sync.completed + '/' + sync.total + ' ' + ((sync.completed / sync.total) * 100).toFixed(0) + '% ' + sync.section) }}
                  </b-progress-bar>
                </b-progress>
              </div>
              <div class="ml-0 mt-1">
                <b-button v-if="sync.section != null" size="sm" @click="halt" variant="link" v-b-popover.hover.top="'Click to stop. It may take a few minutes to clean up. This process can be continued later'"><b-icon-stop-fill shift-v="+1" font-scale="1.0"></b-icon-stop-fill></b-button>
              </div>
              <div class="mt-0 flex-grow-1">
              </div>
              <div class="mt-0 pl-1">
                <b-form-select size="sm" v-model="settings.tokensTable.sortOption" @change="saveSettings" :options="tokensSortOptions" v-b-popover.hover.top="'Yeah. Sort'"></b-form-select>
              </div>
              <div class="mt-0 pl-1">
                <font size="-2" v-b-popover.hover.top="'# tokens'">{{ filteredSortedTokens.length + '/' + tokens.length }}</font>
              </div>
              <div class="mt-0 pl-1">
                <b-pagination size="sm" v-model="settings.tokensTable.currentPage" @input="saveSettings" :total-rows="filteredSortedTokens.length" :per-page="settings.tokensTable.pageSize" style="height: 0;"></b-pagination>
              </div>
              <div class="mt-0 pl-1">
                <b-form-select size="sm" v-model="settings.tokensTable.pageSize" @change="saveSettings" :options="pageSizes" v-b-popover.hover.top="'Tokens page size'"></b-form-select>
              </div>
            </div>

            <!-- ADDITIONAL FILTERS -->
            <div v-if="settings.showAdditionalFilters" class="d-flex flex-wrap m-0 p-0">
              <div class="mt-0 pr-1" style="width: 13.0rem;">
                <b-card no-header no-body class="m-0 mt-1 p-0 border-1">
                  <b-card-body class="m-0 p-0">
                    <font size="-2">
                      <b-table small fixed striped sticky-header="200px" :fields="groupsFilterFields" :items="getAllGroups" head-variant="light">
                        <template #cell(select)="data">
                          <b-form-checkbox size="sm" :checked="(settings.filters['groups'] && settings.filters['groups'][data.item.group]) ? 1 : 0" value="1" @change="filterChanged('groups', data.item.group)"></b-form-checkbox>
                        </template>
                        <template #cell(group)="data">
                          {{ data.item.group }}
                        </template>
                      </b-table>
                    </font>
                  </b-card-body>
                </b-card>
              </div>

              <div class="mt-0 pr-1" style="width: 13.0rem;">
                <b-card no-header no-body class="m-0 mt-1 p-0 border-1">
                  <b-card-body class="m-0 p-0">
                    <font size="-2">
                      <b-table small fixed striped sticky-header="200px" :fields="accountsFilterFields" :items="getAllAccounts" head-variant="light">
                        <template #cell(select)="data">
                          <b-form-checkbox size="sm" :checked="(settings.filters['accounts'] && settings.filters['accounts'][data.item.account]) ? 1 : 0" value="1" @change="filterChanged('accounts', data.item.account)"></b-form-checkbox>
                        </template>
                        <template #cell(account)="data">
                          {{ data.item.accountName }}
                        </template>
                      </b-table>
                    </font>
                  </b-card-body>
                </b-card>
              </div>

              <div class="mt-0 pr-1" style="width: 13.0rem;">
                <b-card no-header no-body class="m-0 mt-1 p-0 border-1">
                  <b-card-body class="m-0 p-0">
                    <font size="-2">
                      <b-table small fixed striped sticky-header="200px" :fields="collectionsFilterFields" :items="getAllCollections" head-variant="light">
                        <template #cell(select)="data">
                          <b-form-checkbox size="sm" :checked="(settings.filters['collections'] && settings.filters['collections'][data.item.collection]) ? 1 : 0" value="1" @change="filterChanged('collections', data.item.collection)"></b-form-checkbox>
                        </template>
                        <template #cell(account)="data">
                          {{ data.item.collectionName }}
                        </template>
                      </b-table>
                    </font>
                  </b-card-body>
                </b-card>
              </div>

            </div>

            <b-table small fixed striped responsive hover :fields="tokensFields" :items="pagedFilteredSortedTokens" show-empty empty-html="Click [+] above to add new collections" head-variant="light" class="mx-0 my-1">
              <template #cell(number)="data">
                <!--
                <b-form-checkbox size="sm" :checked="selectedCollections[data.item.contract] ? 1 : 0" value="1" @change="toggleSelectedCollections([data.item])">
                  {{ parseInt(data.index) + ((settings.collections.currentPage - 1) * settings.collections.pageSize) + 1 }}
                </b-form-checkbox>
                -->
                {{ parseInt(data.index) + ((settings.tokensTable.currentPage - 1) * settings.tokensTable.pageSize) + 1 }}
              </template>
              <template #cell(token)="data">
                <div class="d-flex flex-row">
                  <div>
                    <b-avatar rounded variant="light" size="8.0rem" :src="data.item.image">
                    </b-avatar>
                  </div>
                  <div class="ml-2">
                    <b-link @click="showModalToken(data.item);">{{ data.item.name }}</b-link>
                    <br />
                    {{ data.item.collectionName }}
                    <br />
                    {{ data.item.tokenId }}
                    <br />
                    {{ data.item.ownerName }}
                    <br />
                    <b-button size="sm" @click="requestReservoirAPITokenMetadataRefresh(data.item)" variant="link" v-b-popover.hover.top="'Request a metadata refresh on the Reservoir API. Re-sync after a few minutes'"><b-icon-arrow-clockwise shift-v="+1" font-scale="1.2"></b-icon-arrow-clockwise></b-button>
                    <!-- Volume: 1d {{ commify(data.item.volume["1day"]) + 'e' }}; 7d {{ commify(data.item.volume["7day"]) + 'e' }}; 30d {{ commify(data.item.volume["30day"]) + 'e' }}; allTime {{ commify(data.item.volume["allTime"]) + 'e' }}; tokens {{ data.item.tokenCount }}; onSale {{ data.item.onSaleCount }} -->
                  </div>
                </div>
              </template>
              <template #cell(lastSaleAmount)="data">
                <div v-if="data.item.lastSale">
                  {{ data.item.lastSale.amount }} {{ data.item.lastSale.currency }} <font size="-2">{{ data.item.lastSale.amountInUSD }} USD</font>
                </div>
              </template>
              <template #cell(lastSaleTime)="data">
                <div v-if="data.item.lastSale">
                  {{ formatTimestamp(data.item.lastSale.timestamp) }}
              </div>
              </template>
            </b-table>
          </b-card>
          <b-card v-if="settings.tabIndex == 1" class="m-0 p-0 border-0" body-class="m-1 p-0" header-class="m-0 p-2">
            <b-card-text>
              TODO
            </b-card-text>
          </b-card>
          <b-card v-if="settings.tabIndex == 2" class="m-0 p-0 border-0" body-class="m-1 p-0" header-class="m-0 p-2">
            <div class="d-flex flex-wrap m-0 p-0">
              <div class="mt-0 pr-1">
                <b-form-input type="text" size="sm" v-model.trim="settings.accountsTable.filter" @change="saveSettings" debounce="600" v-b-popover.hover.top="'Account address/name filter'" placeholder="ðŸ” add/name regex" style="min-width: 8.0rem;"></b-form-input>
              </div>
              <div class="mt-0 flex-grow-1">
              </div>
              <!--
              <div v-if="!sync.section" class="mt-0 pr-1">
                <b-button size="sm" :pressed.sync="settings.editAccounts" @click="saveSettings" :variant="settings.editAccounts ? 'danger' : 'link'" v-b-popover.hover.top="settings.editAccounts ? 'End adding/editing accounts. Click Sync to apply changes' : 'Add/Edit accounts'"><b-icon-pencil shift-v="+1" font-scale="1.0"></b-icon-pencil></b-button>
              </div>
              <div class="mt-0 flex-grow-1">
              </div>
              -->
              <div class="mt-0 pr-1">
                <b-dropdown size="sm" variant="link" v-b-popover.hover.top="'Export/Import accounts'">
                  <template #button-content>
                    <b-icon-file-earmark-spreadsheet shift-v="+1" font-scale="1.2"></b-icon-file-earmark-spreadsheet>
                  </template>
                  <b-dropdown-item @click="exportAccounts" >Export</b-dropdown-item>
                  <b-dropdown-item @click="showModalAccountsImport();">Import</b-dropdown-item>
                </b-dropdown>
              </div>
              <div class="mt-0 flex-grow-1">
              </div>
              <div class="mt-0 pl-1">
                <b-form-select size="sm" v-model="settings.accountsTable.sortOption" @change="saveSettings" :options="accountsSortOptions" v-b-popover.hover.top="'Yeah. Sort'"></b-form-select>
              </div>
              <div class="mt-0 pl-1">
                <font size="-2" v-b-popover.hover.top="'# tokens'">{{ filteredSortedAccounts.length + '/' + Object.keys(settings.accounts).length }}</font>
              </div>
              <div class="mt-0 pl-1">
                <b-pagination size="sm" v-model="settings.accountsTable.currentPage" @input="saveSettings" :total-rows="filteredSortedAccounts.length" :per-page="settings.accountsTable.pageSize" style="height: 0;"></b-pagination>
              </div>
              <div class="mt-0 pl-1">
                <b-form-select size="sm" v-model="settings.accountsTable.pageSize" @change="saveSettings" :options="pageSizes" v-b-popover.hover.top="'Tokens page size'"></b-form-select>
              </div>
            </div>

            <b-table small fixed striped responsive hover :fields="accountsFields" :items="pagedFilteredSortedAccounts" show-empty empty-html="Click [+] above to add new collections" head-variant="light" class="mx-0 my-1">
              <template #head(address)="data">
                Account <b-button v-b-modal.new-address-modal-prevent-closing variant="link" v-b-popover.hover.top="'Add new account'"><b-icon-plus-square shift-v="+1" font-scale="0.8"></b-icon-plus-square></b-button>
                <b-modal id="new-address-modal-prevent-closing" ref="modal" title="New Address" @show="newAddressResetModal" @hidden="newAddressResetModal" @ok="newAddressHandleOk">
                  <form ref="form" @submit.stop.prevent="newAddressHandleSubmit">
                    <b-form-group label="Address" label-for="name-input" :state="newAddressState" invalid-feedback="Please enter a valid Ethereum address">
                      <b-form-input id="name-input" v-model="newAddress" :state="newAddressState" required placeholder="0x1234..."></b-form-input>
                    </b-form-group>
                  </form>
                </b-modal>
              </template>
              <template #head(sync)="data">
                Sync
                <b-dropdown size="sm" variant="link" v-b-popover.hover="'Toggle selection'">
                  <template #button-content>
                    <b-icon-check-square shift-v="+1" font-scale="0.9"></b-icon-check-square>
                  </template>
                  <b-dropdown-item href="#" @click="toggleSyncAccounts(pagedFilteredSortedAccounts)">Toggle sync for all accounts on this page</b-dropdown-item>
                  <b-dropdown-item href="#" @click="toggleSyncAccounts(filteredSortedAccounts)">Toggle sync for all accounts on all pages</b-dropdown-item>
                </b-dropdown>
              </template>
              <template #head(include)="data">
                Include
                <b-dropdown size="sm" variant="link" v-b-popover.hover="'Toggle selection'">
                  <template #button-content>
                    <b-icon-check-square shift-v="+1" font-scale="0.9"></b-icon-check-square>
                  </template>
                  <b-dropdown-item href="#" @click="toggleIncludeAccounts(pagedFilteredSortedAccounts)">Toggle include for all accounts on this page</b-dropdown-item>
                  <b-dropdown-item href="#" @click="toggleIncludeAccounts(filteredSortedAccounts)">Toggle include for all accounts on all pages</b-dropdown-item>
                </b-dropdown>
              </template>
              <template #cell(group)="data">
                <b-form-input type="text" size="sm" v-model.trim="data.item.group" @change="setAccountField(data.item.address, 'group', $event)" placeholder="group"></b-form-input>
              </template>
              <template #cell(name)="data">
                <b-form-input type="text" size="sm" v-model.trim="data.item.name" @change="setAccountField(data.item.address, 'name', $event)" placeholder="name"></b-form-input>
              </template>
              <template #cell(sync)="data">
                <b-form-checkbox size="sm" :checked="data.item.sync ? 1 : 0" value="1" @change="toggleAccountField(data.item.address, 'sync')" v-b-popover.hover="'Include in sync process?'"></b-form-checkbox>
              </template>
              <template #cell(include)="data">
                <b-form-checkbox size="sm" :checked="data.item.include ? 1 : 0" value="1" @change="toggleAccountField(data.item.address, 'include')" v-b-popover.hover="'Include in NFTs view?'"></b-form-checkbox>
              </template>
              <template #cell(delete)="data">
                <b-button size="sm" @click="deleteAccount(data.item.address)" variant="link" v-b-popover.hover="'Delete account'"><b-icon-trash style="color: #ff0000;" shift-v="+1" font-scale="1.0"></b-icon-trash></b-button>
              </template>
            </b-table>
          </b-card>
        </b-card>
        <b-card no-header body-class="m-0 p-0" class="m-0 p-0 border-0">
          <b-card-text class="text-right">
            gm, and enjoy! <i>MyNFTs</i> &copy; Bok Consulting Pty Ltd 2023.
          </b-card-text>
        </b-card no-header>
      </b-container>
    </div>

    <script>
      window.app = new Vue({
        el: '#app',
        // --- DATA ---
        data: {
          coinbase: null,
          settings: {
            tabIndex: 0,
            showAdditionalFilters: false,
            filters: {},
            editAccounts: false,
            accounts: {},
            accountsTable: {
              filter: null,
              currentPage: 1,
              pageSize: 10,
              sortOption: 'lastsaledsc',
            },
            tokensTable: {
              tokenFilter: null,
              collectionFilter: null,
              currentPage: 1,
              pageSize: 10,
              sortOption: 'lastsaledsc',
            },
            version: 9,
          },
          newAddress: null,
          restoreFile: null,
          restoreAddresses: null,
          sync: {
            section: null,
            total: null,
            completed: null,
            halt: false,
          },
          modalToken: {
            token: null,
            collection: null,
          },

          collections: {},
          tokens: [],
          ensMap: {},
          selectedCollections: {},
          selectedMainTable: {},
          accountsSortOptions: [
            { value: 'groupnameasc', text: 'â–² Group, â–² Name' },
            { value: 'groupnamedsc', text: 'â–¼ Group, â–² Name' },
            { value: 'nameasc', text: 'â–² Name' },
            { value: 'namedsc', text: 'â–¼ Name' },
          ],
          tokensSortOptions: [
            { value: 'lastsaleasc', text: 'â–² Last Sale' },
            { value: 'lastsaledsc', text: 'â–¼ Last Sale' },
          ],
          pageSizes: [
            { value: 5, text: '5' },
            { value: 10, text: '10' },
            { value: 25, text: '25' },
            { value: 50, text: '50' },
            { value: 100, text: '100' },
            { value: 500, text: '500' },
            { value: 1000, text: '1k' },
            { value: 2500, text: '2.5k' },
            { value: 10000, text: '10k' },
          ],
          accountsFields: [
            { key: 'address', label: '#', sortable: false, thStyle: 'width: 30%;', tdClass: 'text-truncate' },
            { key: 'group', label: 'Group', sortable: false, thStyle: 'width: 20%;', tdClass: 'text-truncate' },
            { key: 'name', label: 'Name', sortable: false, thStyle: 'width: 20%;', tdClass: 'text-truncate' },
            // { key: 'ensName', label: 'ENS Name', sortable: false, thStyle: 'width: 15%;', tdClass: 'text-truncate' },
            { key: 'sync', label: 'Sync', sortable: false, thStyle: 'width: 10%;', tdClass: 'text-truncate' },
            { key: 'include', label: 'Include', sortable: false, thStyle: 'width: 10%;', tdClass: 'text-truncate' },
            { key: 'delete', label: 'Delete', sortable: false, thStyle: 'width: 10%;', tdClass: 'text-truncate' },
          ],
          tokensFields: [
            { key: 'number', label: '#', sortable: false, thStyle: 'width: 5%;', tdClass: 'text-truncate' },
            { key: 'token', label: 'Token', sortable: false, thStyle: 'width: 55%;', tdClass: 'text-truncate' },
            { key: 'lastSaleAmount', label: 'Last Sale Amount', sortable: false, thStyle: 'width: 20%;', tdClass: 'text-truncate' },
            { key: 'lastSaleTime', label: 'Last Sale', sortable: false, thStyle: 'width: 20%;', tdClass: 'text-truncate' },
          ],
          groupsFilterFields: [
            { key: 'select', label: '', thStyle: 'width: 15%;' },
            { key: 'group', label: 'Group', sortable: true, tdClass: 'text-truncate' },
            { key: 'count', label: '#', sortable: true, thStyle: 'width: 20%;', thClass: 'text-right', tdClass: 'text-right' },
          ],
          accountsFilterFields: [
            { key: 'select', label: '', thStyle: 'width: 15%;' },
            { key: 'account', label: 'Account', sortable: true, tdClass: 'text-truncate' },
            { key: 'count', label: '#', sortable: true, thStyle: 'width: 20%;', thClass: 'text-right', tdClass: 'text-right' },
          ],
          collectionsFilterFields: [
            { key: 'select', label: '', thStyle: 'width: 15%;' },
            { key: 'collectionName', label: 'Collection', sortable: true, tdClass: 'text-truncate' },
            { key: 'count', label: '#', sortable: true, thStyle: 'width: 20%;', thClass: 'text-right', tdClass: 'text-right' },
          ],
          accountsImportAddressesFields: [
            { key: 'address', label: 'Address', sortable: true, thStyle: 'width: 60%;', tdClass: 'text-truncate' },
            { key: 'name', label: 'Name', sortable: true, thStyle: 'width: 20%;', tdClass: 'text-truncate' },
            { key: 'group', label: 'Group', sortable: true, thStyle: 'width: 20%;', tdClass: 'text-truncate' },
            // { key: 'sync', label: 'Sync', sortable: true, thStyle: 'width: 10%;', tdClass: 'text-truncate' },
            // { key: 'include', label: 'Include', sortable: true, thStyle: 'width: 10%;', tdClass: 'text-truncate' },
          ],
          db: {
            name: "mynfts089",
            version: 1,
            schemaDefinition: {
              cache: '&objectName',
            },
            updated: null,
          },
        },

        // --- COMPUTED ---
        computed: {
          getAllGroups() {
            const groupsMap = {};
            for (const token of this.filteredTokens) {
              const accountInfo = this.settings.accounts[token.owner] || {};
              const group = accountInfo.group || "(blank)";
              if (!(group in groupsMap)) {
                groupsMap[group] = 0;
              }
              groupsMap[group]++;
            }
            const results = [];
            for (const [group, count] of Object.entries(groupsMap)) {
              results.push({ group, count });
            }
            results.sort((a, b) => {
              if (('' + a.group).localeCompare(b.group) == 0) {
                results.sort((a, b) => a.count - b.count);
              } else {
                return ('' + a.group).localeCompare(b.group);
              }
            });
            return results;
          },
          getAllAccounts() {
            const accountsMap = {};
            for (const token of this.filteredTokens) {
              if (!(token.owner in accountsMap)) {
                accountsMap[token.owner] = 0;
              }
              accountsMap[token.owner]++;
            }
            const results = [];
            for (const [account, count] of Object.entries(accountsMap)) {
              const accountInfo = this.settings.accounts[account] || {};
              const accountName = accountInfo.name && (accountInfo.name + ' ' + account.substring(0, 8)) || account.substring(0, 16);
              results.push({ account, accountName, count });
            }
            results.sort((a, b) => {
              if (('' + a.accountName).localeCompare(b.accountName) == 0) {
                results.sort((a, b) => a.count - b.count);
              } else {
                return ('' + a.accountName).localeCompare(b.accountName);
              }
            });
            return results;
          },
          getAllCollections() {
            const collectionsMap = {};
            for (const token of this.filteredTokens) {
              if (!(token.contract in collectionsMap)) {
                collectionsMap[token.contract] = 0;
              }
              collectionsMap[token.contract]++;
            }
            const results = [];
            for (const [contract, count] of Object.entries(collectionsMap)) {
              const collectionInfo = this.collections[contract] || {};
              results.push({ collection: contract, collectionName: collectionInfo.name, count });
            }
            results.sort((a, b) => {
              if (('' + a.collectionName).localeCompare(b.collectionName) == 0) {
                results.sort((a, b) => a.count - b.count);
              } else {
                return ('' + a.collectionName).localeCompare(b.collectionName);
              }
            });
            return results;
          },
          newAddressState() {
            let status = false;
            if (this.newAddress) {
              try {
                // console.log("newAddressState: " + this.newAddress.address)
                const a = ethers.utils.getAddress(this.newAddress);
                status = a && a.length > 0;
                // console.log("newAddressState: " + status);
                return status;
              } catch (e) {
                // console.log(e);
                return false;
              }
            }
            return null;
          },
          filteredAccounts() {
            const results = [];
            const filterRegex = this.settings.accountsTable.filter && this.settings.accountsTable.filter.length > 0 ? new RegExp(this.settings.accountsTable.filter, 'i') : null;
            for (const [address, item] of Object.entries(this.settings.accounts)) {
              let include = true;
              if (filterRegex) {
                if (!filterRegex.test(item.name) && !filterRegex.test(item.group) && !filterRegex.test(address)) {
                  include = false;
                }
              }
              if (include) {
                results.push({
                  address,
                  name: item.name,
                  ensName: item.ensName,
                  group: item.group,
                  sync: item.sync,
                  include: item.include,
                });
              }
            }
            return results;
          },
          filteredSortedAccounts() {
            let results = this.filteredAccounts;
            if (this.settings.accountsTable.sortOption == 'groupnameasc') {
              results.sort((a, b) => {
                if (('' + a.group).localeCompare(b.group) == 0) {
                  if (('' + a.name).localeCompare(b.name) == 0) {
                    return ('' + a.account).localeCompare(b.account);
                  } else {
                    return ('' + a.name).localeCompare(b.name);
                  }
                } else {
                  return ('' + a.group).localeCompare(b.group);
                }
              });
            } else if (this.settings.accountsTable.sortOption == 'groupnamedsc') {
              results.sort((a, b) => {
                if (('' + a.group).localeCompare(b.group) == 0) {
                  if (('' + a.name).localeCompare(b.name) == 0) {
                    return ('' + a.account).localeCompare(b.account);
                  } else {
                    return ('' + a.name).localeCompare(b.name);
                  }
                } else {
                  return ('' + b.group).localeCompare(a.group);
                }
              });
            } else if (this.settings.accountsTable.sortOption == 'nameasc') {
              results.sort((a, b) => {
                if (('' + a.name).localeCompare(b.name) == 0) {
                  return ('' + a.account).localeCompare(b.account);
                } else {
                  return ('' + a.name).localeCompare(b.name);
                }
              });
            } else if (this.settings.accountsTable.sortOption == 'namedsc') {
              results.sort((a, b) => {
                if (('' + a.name).localeCompare(b.name) == 0) {
                  return ('' + a.account).localeCompare(b.account);
                } else {
                  return ('' + b.name).localeCompare(a.name);
                }
              });
            } else {
              results.sort((a, b) => {
                if (('' + a.group).localeCompare(b.group) == 0) {
                  if (('' + a.name).localeCompare(b.name) == 0) {
                    return ('' + a.account).localeCompare(b.account);
                  } else {
                    return ('' + a.name).localeCompare(b.name);
                  }
                } else {
                  return ('' + a.group).localeCompare(b.group);
                }
              });
            }
            return results;
          },
          pagedFilteredSortedAccounts() {
            return this.filteredSortedAccounts.slice((this.settings.accountsTable.currentPage - 1) * this.settings.accountsTable.pageSize, this.settings.accountsTable.currentPage * this.settings.accountsTable.pageSize);
          },
          filteredTokens() {
            const tokenFilterRegex = this.settings.tokensTable.tokenFilter && this.settings.tokensTable.tokenFilter.length > 0 ? new RegExp(this.settings.tokensTable.tokenFilter, 'i') : null;
            const searchCollectionLower = this.settings.tokensTable.collectionfilter && this.settings.tokensTable.collectionfilter.toLowerCase() || null;
            let groupFilter = null;
            if (this.settings.filters.groups && Object.keys(this.settings.filters.groups).length > 0) {
              groupFilter = this.settings.filters.groups;
            }
            let accountFilter = null;
            if (this.settings.filters.accounts && Object.keys(this.settings.filters.accounts).length > 0) {
              accountFilter = this.settings.filters.accounts;
            }
            let collectionFilter = null;
            if (this.settings.filters.collections && Object.keys(this.settings.filters.collections).length > 0) {
              collectionFilter = this.settings.filters.collections;
            }
            const results = [];
            for (const token of this.tokens) {
              let include = true;
              const collectionName = this.collections[token.contract] && this.collections[token.contract].name || null;
              if (tokenFilterRegex) {
                if (!tokenFilterRegex.test(token.name) && !tokenFilterRegex.test(token.tokenId.toString())) {
                  include = false;
                }
              }
              if (include && searchCollectionLower) {
                if (!(collectionName && collectionName.toLowerCase().includes(searchCollectionLower))) {
                  include = false;
                }
              }
              if (include && groupFilter) {
                const accountInfo = this.settings.accounts[token.owner] || {};
                const group = accountInfo.group || "(blank)";
                if (!(group in groupFilter)) {
                  include = false;
                }
              }
              if (include && accountFilter) {
                if (!(token.owner in accountFilter)) {
                  include = false;
                }
              }
              if (include && collectionFilter) {
                if (!(token.contract in collectionFilter)) {
                  include = false;
                }
              }
              if (include) {
                const ownerInfo = this.settings.accounts[token.owner] || {};
                const ownerName = ownerInfo.name && (ownerInfo.name + ' ' + token.owner.substring(0, 8)) || token.owner.substring(0, 16);
                results.push({
                  ...token,
                  ownerName,
                  collectionName,
                  lastSale: {
                    timestamp: token.lastSale && token.lastSale.timestamp || null,
                    amount: token.lastSale && token.lastSale.price && token.lastSale.price.amount && token.lastSale.price.amount.native || null,
                    currency: token.lastSale && token.lastSale.price && token.lastSale.price.currency && token.lastSale.price.currency.symbol || null,
                    amountInUSD: token.lastSale && token.lastSale.price && token.lastSale.price.amount && token.lastSale.price.amount.usd || null,
                  },
                });
              }
            }
            return results;
          },
          filteredSortedTokens() {
            let results = this.filteredTokens;
            if (this.settings.tokensTable.sortOption == 'lastsaleasc') {
              results.sort((a, b) => {
                const lastSaleA = a.lastSale && a.lastSale.timestamp || 0;
                const lastSaleB = b.lastSale && b.lastSale.timestamp || 0;
                return lastSaleA - lastSaleB;
              });
            } else if (this.settings.tokensTable.sortOption == 'lastsaledsc') {
              results.sort((a, b) => {
                const lastSaleA = a.lastSale && a.lastSale.timestamp || 0;
                const lastSaleB = b.lastSale && b.lastSale.timestamp || 0;
                return lastSaleB - lastSaleA;
              });
            }
            return results;
          },
          pagedFilteredSortedTokens() {
            return this.filteredSortedTokens.slice((this.settings.tokensTable.currentPage - 1) * this.settings.tokensTable.pageSize, this.settings.tokensTable.currentPage * this.settings.tokensTable.pageSize);
          },
        },

        // --- METHODS ---
        methods: {
          checkFormValidity() {
            const valid = this.$refs.form.checkValidity()
            if (this.newAddress && this.newAddress.length > 0) {
              try {
                const a = ethers.utils.getAddress(this.newAddress);
                status = a && a.length > 0;
                return status;
              } catch (e) {
                return false;
              }
            } else {
              return valid;
            }
          },
          newAddressResetModal() {
            this.newAddress = null;
          },
          newAddressHandleOk(bvModalEvent) {
            // Prevent modal from closing
            bvModalEvent.preventDefault();
            // Trigger submit handler
            this.newAddressHandleSubmit();
          },
          newAddressHandleSubmit() {
            // Exit when the form isn't valid
            if (!this.checkFormValidity()) {
              return;
            }
            if (!(this.newAddress in this.settings.accounts)) {
              console.log("Adding: " + this.newAddress);
              Vue.set(this.settings.accounts, this.newAddress, {
                name: null,
                ensName: null,
                group: null,
                sync: true,
                include: true,
              });
            } else {
              console.log("Discarding duplicate: " + this.newAddress);
            }
            // Hide the modal manually
            this.$nextTick(() => {
              this.$bvModal.hide('new-address-modal-prevent-closing');
            })
            this.saveSettings();
          },
          toggleAccountField(account, field) {
            Vue.set(this.settings.accounts[account], field, !this.settings.accounts[account][field]);
            this.saveSettings();
          },
          setAccountField(account, field, value) {
            Vue.set(this.settings.accounts[account], field, value);
            this.saveSettings();
          },
          deleteAccount(account) {
            Vue.delete(this.settings.accounts, account);
            this.saveSettings();
          },
          saveSettings() {
            localStorage.myNFTsSettings = JSON.stringify(this.settings);
            // console.log("saveSettings: " + JSON.stringify(this.settings));
          },
          filterChanged(dataType, option) {
            console.log("filterChanged - dataType: " + dataType + ", option: " + JSON.stringify(option));
            if (!this.settings.filters[dataType]) {
              Vue.set(this.settings.filters, dataType, {});
            }
            if (this.settings.filters[dataType][option]) {
              Vue.delete(this.settings.filters[dataType], option);
              if (Object.keys(this.settings.filters[dataType]) == 0) {
                Vue.delete(this.settings.filters, dataType);
              }
            } else {
              Vue.set(this.settings.filters[dataType], option, true);
            }
            this.saveSettings();
          },
          resetAdditionalFilters() {
            Vue.set(this.settings, 'filters', {});
            this.saveSettings();
          },
          async showModalAccountsImport(item) {
            // console.log("showModalAccountsImport: " + JSON.stringify(item));
            // let url = "https://api.reservoir.tools/collections/v5?contract=" + item.contract;
            // console.log(url);
            // const data = await fetch(url).then(response => response.json());
            // const collection = data.collections && data.collections.length == 1 && data.collections[0] || {};
            // this.modalToken = {
            //   token: item,
            //   collection,
            // };
            // console.log(JSON.stringify(this.modalToken, null, 2));
            this.$bvModal.show('modal-accounts-import');
          },
          async showModalToken(item) {
            // console.log("showModalToken: " + JSON.stringify(item));
            let url = "https://api.reservoir.tools/collections/v5?contract=" + item.contract;
            console.log(url);
            const data = await fetch(url).then(response => response.json());
            const collection = data.collections && data.collections.length == 1 && data.collections[0] || {};
            this.modalToken = {
              token: item,
              collection,
            };
            console.log(JSON.stringify(this.modalToken, null, 2));
            this.$bvModal.show('modal-token');
          },
          toggleSyncAccounts(items) {
            let someFalse = false;
            let someTrue = false;
            for (const item of items) {
              if (item.sync) {
                someTrue = true;
              } else {
                someFalse = true;
              }
            }
            for (const item of items) {
              Vue.set(this.settings.accounts[item.address], 'sync', !(someTrue && !someFalse));
            }
            this.saveSettings();
          },
          toggleIncludeAccounts(items) {
            let someFalse = false;
            let someTrue = false;
            for (const item of items) {
              if (item.include) {
                someTrue = true;
              } else {
                someFalse = true;
              }
            }
            for (const item of items) {
              Vue.set(this.settings.accounts[item.address], 'include', !(someTrue && !someFalse));
            }
            this.saveSettings();
          },
          async syncAccounts() {
            console.log("syncAccounts");
            const db0 = new Dexie(this.db.name);
            db0.version(this.db.version).stores(this.db.schemaDefinition);
            for (const [address, accountItem] of Object.entries(this.settings.accounts)) {
              console.log("Processing: " + address + " " + JSON.stringify(accountItem));
              if (accountItem.sync && !this.sync.halt) {
                const accountInfo = this.settings.accounts[address] || {};
                this.sync.completed = 0;
                this.sync.total = null;
                this.sync.section = accountInfo.name || address.substring(0, 8);
                const tokens = [];
                let continuation = null;
                const LIMIT = 200; // 200 max
                do {
                  let url = "https://api.reservoir.tools/users/" + address + "/tokens/v7?limit=" + LIMIT + "&includeTopBid=true&includeAttributes=true&includeLastSale=true&includeRawData=true" +
                    (continuation != null ? "&continuation=" + continuation : '');
                  console.log("url: " + url);
                  const data = await fetch(url)
                    .then(handleErrors)
                    .then(response => response.json())
                    .catch(function(error) {
                       console.log("ERROR - syncAccounts: " + error);
                       // state.sync.error = true;
                       return [];
                    });
                  continuation = data.continuation;
                  if (data && data.tokens) {
                    for (const tokenData of data.tokens) {
                      if (tokenData && tokenData.token) {
                        tokens.push(tokenData.token);
                      }
                    }
                    this.sync.completed = tokens.length;
                  }
                  await delay(1000); // TODO: Adjust to avoid errors 429 Too Many Requests.
                } while (continuation != null && !this.sync.halt /*&& !state.sync.error */);
                if (!this.sync.halt) {
                  console.log("tokens: " + JSON.stringify(tokens, null, 2));
                  await db0.cache.put({ objectName: address, object: tokens }).then (function() {
                  }).catch(function(error) {
                    console.log("error: " + error);
                  });
                  await delay(1500); // TODO: Adjust to avoid error 429 Too Many Requests.
                }
              }
            }
            this.sync.section = null;
            this.sync.halt = false;
            db0.close();
            await this.loadNFTs();
          },
          async loadNFTs() {
            const db0 = new Dexie(this.db.name);
            db0.version(this.db.version).stores(this.db.schemaDefinition);
            const collections = {};
            const tokens = [];
            for (const [address, accountItem] of Object.entries(this.settings.accounts)) {
              if (accountItem.include) {
                // console.log("Including: " + address + " " + JSON.stringify(accountItem));
                const tokensData = await db0.cache.where("objectName").equals(address).toArray();
                if (tokensData.length == 1) {
                  for (const token of tokensData[0].object) {
                    // console.log(JSON.stringify(token));
                    const contract = ethers.utils.getAddress(token.contract);
                    if (!(contract in collections)) {
                      collections[contract] = {
                        name: token.collection.name,
                        imageUrl: token.collection.imageUrl,
                        floorAskPrice: token.collection.floorAskPrice,
                        royaltiesBps: token.collection.royaltiesBps,
                        // royalties: token.collection.royalties,
                      };
                    }
                    tokens.push({
                      owner: address,
                      contract,
                      tokenId: token.tokenId,
                      kind: token.kind,
                      name: token.name,
                      image: token.image,
                      media: token.media,
                      rarityScore: token.rarityScore,
                      rarityRank: token.rarityRank,
                      lastSale: token.lastSale,
                      topBid: token.topBid,
                    });
                  }
                }

              }
            }
            db0.close();
            // console.log(JSON.stringify(collections, null, 2));
            // console.log(JSON.stringify(tokens, null, 2));
            this.collections = collections;
            this.tokens = tokens;
          },
          async requestReservoirAPITokenMetadataRefresh(token) {
            console.log("requestReservoirAPITokenMetadataRefresh - token: " + JSON.stringify(token));
            const options = {
              method: 'POST',
              // mode: 'no-cors', // cors, no-cors, *cors, same-origin
              headers: {accept: '*/*', 'content-type': 'application/json', 'x-api-key': 'demo-api-key'},
              body: JSON.stringify({
                overrideCoolDown: false,
                token: token.contract + ':' + token.tokenId,
              })
            };
            // console.log("options: " + JSON.stringify(options, null, 2));
            const results = await fetch('https://api.reservoir.tools/tokens/refresh/v1', options)
              .then(response => response.json())
              .then(response => console.log(response))
              .catch(err => console.error(err));
            console.log("results: " + JSON.stringify(results));

            this.$bvToast.toast("Please Sync after a few minutes", {
              title: 'Metadata refresh ' + token.contract.substring(0, 12) + '...:' + token.tokenId.substring(0, 12),
              autoHideDelay: 5000,
              appendToast: true,
            });
            // setTimeout(function() {
            //   store.dispatch('data/refreshTokenMetadata', token);
            // }, 5000);
            // alert("Request sent and will data will be auto-refreshed in 5 seconds. Manually refresh the locally cached token metadata if required")
          },

          async halt() {
            this.sync.halt = true;
            console.log("this.sync.halt: " + this.sync.halt);
          },
          commify(n) {
            if (n != null) {
              return ethers.utils.commify(n);
            }
            return null;
          },
          formatTimestamp(ts) {
            if (ts != null) {
              return moment.unix(ts).format("YYYY-MM-DD HH:mm:ss");
            }
            return null;
          },
          formatETH(e) {
            try {
              return e ? parseFloat(ethers.utils.formatEther(e)).toFixed(9) : null;
            } catch (err) {
            }
            return e.toFixed(9);
          },
          ensOrAddress(address, length = 0) {
            if (this.ensMap) {
              if (address in this.ensMap) {
                return length == 0 ? this.ensMap[address] : this.ensMap[address].substring(0, length);
              }
            }
            return address == null ? null : (length == 0 ? address : address.substring(0, length));
          },
          exportTxHashes() {
            console.log("exportTxHashes");
            var dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(this.txHashes));
            var link = document.createElement("a");
            link.setAttribute("href", dataStr);
            link.setAttribute("download", "txhashes.json");
            document.body.appendChild(link); // Required for FF
            link.click();
          },
          exportAccounts() {
            console.log("exportAccounts");
            const rows = [
                ["No", "Address", "Name", "ENSName", "Group", "Sync", "Include"],
            ];
            let i = 1;
            for (const result of this.filteredSortedAccounts) {
              rows.push([
                i,
                result.address,
                result.name,
                result.ensName,
                result.group,
                result.sync ? "y" : "n",
                result.include ? "y" : "n",
              ]);
              i++;
            }
            let tsvContent = "data:text/tsv;charset=utf-8," + rows.map(e => e.join("\t")).join("\n");
            var encodedUri = encodeURI(tsvContent);
            var link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", "mynfts_account_export-" + moment().format("YYYY-MM-DD-HH-mm-ss") + ".tsv");
            document.body.appendChild(link); // Required for FF
            link.click(); // This will download the data with the specified file name
          },
          async backupFilesChange(fileName, fileList) {
            const reader = new FileReader();
            this.restoreAddresses = [];
            const t = this;
            reader.onload = function (event) {
              const data = event.target.result;
              const lines = data.split("\n");
              for (const line of lines) {
                const fields = line.split("\t");
                // console.log(JSON.stringify(fields));
                if (fields[0] != "No") {
                  const [number, address, name, ensName, group, sync, include]  = fields;
                  t.restoreAddresses.push({ address, name, ensName, group, sync, include });
                }
              }
            };
            await reader.readAsText(fileList[0]);
          },
          restoreFromBackup() {
            if (this.restoreAddresses) {
              for (const addressData of this.restoreAddresses) {
                if (!(addressData.address in this.settings.accounts)) {
                  console.log("Adding: " + JSON.stringify(addressData));
                  Vue.set(this.settings.accounts, addressData.address, {
                    name: addressData.name,
                    ensName: null,
                    group: addressData.group,
                    sync: true,
                    include: true,
                  });
                } else {
                  console.log("Discarding duplicate: " + JSON.stringify(addressData));
                }
              }
              this.saveSettings();
            }
          },
          copyToClipboard(str) {
            // https://github.com/30-seconds/30-seconds-of-code/blob/master/snippets/copyToClipboard.md
            const el = document.createElement('textarea');
            el.value = str;
            el.setAttribute('readonly', '');
            el.style.position = 'absolute';
            el.style.left = '-9999px';
            document.body.appendChild(el);
            const selected =
              document.getSelection().rangeCount > 0
                ? document.getSelection().getRangeAt(0)
                : false;
            el.select();
            document.execCommand('copy');
            document.body.removeChild(el);
            if (selected) {
              document.getSelection().removeAllRanges();
              document.getSelection().addRange(selected);
            }
          },
          async processIt(action, parameters = null) {
            console.log("processIt - action: " + action + ", parameters: " + parameters);
            let connected = true;
            if (!window.ethereum) {
              connected = false;
            } else {
              try {
                const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                connected = window.ethereum.isConnected();
              } catch (e) {
                console.log("window.ethereum.request error: " + e.message);
                connected = false;
              }
            }
            if (!connected) {
              alert("Please use the https://metamask.io addon with Firefox, Chromium, Opera or Chrome, or any other other web3 browser, for web3 data retrieval. And refresh!");
            } else {
              const provider = new ethers.providers.Web3Provider(window.ethereum);
              const signer = provider.getSigner();
              const ensReverseRecordsContract = new ethers.Contract(ENSREVERSERECORDSADDRESS, ENSREVERSERECORDSABI, provider);
              const erc721Helper = new ethers.Contract(ERC721HELPERADDRESS, ERC721HELPERABI, provider);
              this.coinbase = await signer.getAddress();
              localStorage.coinbase = this.coinbase;
              const network = await provider.getNetwork();
              const block = await provider.getBlock("latest");
              const blockNumber = block.number;
              const timestamp = block.timestamp;
              const ENSOWNERBATCHSIZE = 100; // 500 fails occassionally

              const db0 = new Dexie(this.db.name);
              db0.version(this.db.version).stores(this.db.schemaDefinition);

              if (action == "retrieveMainCollection") {
                console.log("retrieveMainCollection");
                let continuation = null;
                this.sync.completed = 0;
                this.sync.total = null;
                this.sync.section = "Main collection";
                const mainTokens = {};
                this.mainToken.collection.name = null;
                do {
                  let url = "https://api.reservoir.tools/tokens/v5?contract=" + this.settings.mainCollection + "&limit=100" +
                    (continuation != null ? "&continuation=" + continuation : '');
                  console.log("url: " + url);
                  const data = await fetch(url)
                    .then(handleErrors)
                    .then(response => response.json())
                    .catch(function(error) {
                       console.log("ERROR - updateCollection: " + error);
                       // state.sync.error = true;
                       return [];
                    });
                  continuation = data.continuation;
                  if (data && data.tokens) {
                    for (const tokenData of data.tokens) {
                      const token = tokenData.token;
                      mainTokens[token.tokenId] = {
                        owner: token.owner,
                        image: token.image,
                      };
                      if (this.mainToken.collection.name == null) {
                        this.mainToken.collection.name = token.collection.name;
                        this.mainToken.collection.image = token.collection.image;
                        this.mainToken.collection.slug = token.collection.slug;
                      }
                    }
                  }
                  this.sync.completed = Object.keys(mainTokens).length;
                  await delay(1500); // TODO: Adjust to avoid error 429 Too Many Requests. Fails at 200ms
                } while (continuation != null /*&& !this.sync.halt && !state.sync.error */);

                const mainOwners = {};
                for (const [tokenId, data] of Object.entries(mainTokens)) {
                  if (!(data.owner in mainOwners)) {
                    mainOwners[data.owner] = [];
                  }
                  mainOwners[data.owner].push(tokenId);
                }

                this.sync.completed = 0;
                const addresses = Object.keys(mainOwners);
                this.sync.total = addresses.length;
                this.sync.section = "ENS Names";
                const ensMap = {};
                for (let i = 0; i < addresses.length & !this.sync.halt; i += ENSOWNERBATCHSIZE) {
                  const batch = addresses.slice(i, parseInt(i) + ENSOWNERBATCHSIZE);
                  const allnames = await ensReverseRecordsContract.getNames(batch);
                  for (let j = 0; j < batch.length; j++) {
                    const address = batch[j];
                    const name = allnames[j];
                    ensMap[address] = name != null && name.length > 0 ? name : address;
                    // const normalized = normalize(address);
                  }
                  this.sync.completed = parseInt(this.sync.completed) + batch.length;
                }
                this.ensMap = ensMap;
                await db0.cache.put({ objectName: 'ensMap', object: ensMap }).then (function() {
                }).catch(function(error) {
                  console.log("error: " + error);
                });
                this.mainToken.tokens = mainTokens;
                this.mainToken.owners = mainOwners;
                await db0.cache.put({ objectName: 'mainToken', object: this.mainToken }).then (function() {
                }).catch(function(error) {
                  console.log("error: " + error);
                });
                this.secondaryData = {};
                await db0.cache.put({ objectName: 'secondaryData', object: this.secondaryData }).then (function() {
                }).catch(function(error) {
                  console.log("error: " + error);
                });
                this.sync.section = null;
              }

              if (action == "syncCollections") {
                console.log("syncCollections");
                let contracts = [];
                if (Object.keys(this.selectedCollections).length > 0) {
                  contracts = Object.keys(this.selectedCollections);
                } else {
                  for (const record of this.filteredSortedCollections) {
                    if (!(record.contract in this.secondaryData)) {
                      contracts.push(record.contract);
                    }
                  }
                }
                console.log("contracts: " + JSON.stringify(contracts));
                for (let contract of contracts) {
                  console.log("Processing: " + contract + " " + JSON.stringify(this.collections[contract]));

                  let continuation = null;
                  this.sync.completed = 0;
                  this.sync.total = null;
                  this.sync.section = this.collections[contract].name.substring(0, 24);
                  const tokens = {};
                  do {
                    let url = "https://api.reservoir.tools/tokens/v5?contract=" + contract + "&includeAttributes=false&limit=100" +
                      (continuation != null ? "&continuation=" + continuation : '');
                    console.log("url: " + url);
                    const data = await fetch(url)
                      .then(handleErrors)
                      .then(response => response.json())
                      .catch(function(error) {
                         console.log("ERROR - updateCollection: " + error);
                         // state.sync.error = true;
                         return [];
                      });
                    continuation = data.continuation;
                    if (data && data.tokens) {
                      for (const tokenData of data.tokens) {
                        const token = tokenData.token;
                        tokens[token.tokenId] = {
                          owner: token.owner,
                          image: token.image,
                        };
                      }
                    }
                    this.sync.completed = Object.keys(tokens).length;
                    await delay(1500); // TODO: Adjust to avoid error 429 Too Many Requests. Fails at 200ms
                  } while (continuation != null /*&& !this.sync.halt && !state.sync.error */);
                  Vue.set(this.collections[contract], 'tokens', tokens);
                  const owners = {};
                  for (const [tokenId, data] of Object.entries(tokens)) {
                    if (!(data.owner in owners)) {
                      owners[data.owner] = [];
                    }
                    owners[data.owner].push(tokenId);
                  }
                  Vue.set(this.collections[contract], 'owners', owners);
                  Vue.set(this.collections[contract], 'updated', timestamp);
                  Vue.set(this.collections[contract], 'blockNumber', blockNumber);
                }
                await db0.cache.put({ objectName: 'collections', object: this.collections }).then (function() {
                }).catch(function(error) {
                  console.log("error: " + error);
                });
              }

              if (action == "retrieveSecondaryCollection") {
                console.log("retrieveSecondaryCollection");
                let owners = [];
                if (Object.keys(this.selectedMainTable).length > 0) {
                  owners = Object.keys(this.selectedMainTable);
                } else {
                  for (const record of this.filteredSortedMainTable) {
                    if (!(record.owner in this.secondaryData)) {
                      owners.push(record.owner);
                    }
                  }
                }
                console.log("owners: " + JSON.stringify(owners));

                this.sync.completed = 0;
                this.sync.total = owners.count;
                this.sync.section = "Secondary collection";
                for (let owner of owners) {
                  console.log("Processing: " + owner);
                  Vue.set(this.secondaryData, owner, {});
                  let stop = false;
                  const LIMIT = 100;
                  const MAXLIMIT = 10000;
                  for (let offset = 0; offset < MAXLIMIT && !stop; offset = parseInt(offset) + LIMIT) {
                    let url = "https://api.reservoir.tools/users/" + owner + "/tokens/v5?sortBy=acquiredAt&sortDirection=desc&offset=" + offset + "&limit=" + LIMIT + "&includeTopBid=false";
                    console.log("url: " + url);
                    const data = await fetch(url)
                      .then(handleErrors)
                      .then(response => response.json())
                      .catch(function(error) {
                         console.log("ERROR - updateCollection: " + error);
                         // state.sync.error = true;
                         return [];
                      });
                    if (data && data.tokens && data.tokens.length > 0) {
                      for (const tokenData of data.tokens) {
                        const contract = tokenData.token.contract;
                        const tokenId = tokenData.token.tokenId;
                        const name = tokenData.token.name;
                        const image = tokenData.token.image;
                        const collectionName = tokenData.token.collection.name;
                        const collectionImage = tokenData.token.collection.imageUrl;
                        if (!(contract in this.secondaryData[owner])) {
                          Vue.set(this.secondaryData[owner], contract, {
                            collectionName,
                            collectionImage,
                            tokens: {},
                          });
                        }
                        Vue.set(this.secondaryData[owner][contract].tokens, tokenId, { tokenId, name, image });
                      }
                    } else {
                      stop = true;
                    }
                    await delay(1500); // TODO: Adjust to avoid error 429 Too Many Requests. Fails at 200ms
                  }
                  await delay(1000); // TODO: Adjust to avoid error 429 Too Many Requests. Fails at 200ms
                  this.sync.completed = parseInt(this.sync.completed) + 1;
                  if (this.sync.halt) {
                    break;
                  }
                }
                await db0.cache.put({ objectName: 'secondaryData', object: this.secondaryData }).then (function() {
                }).catch(function(error) {
                  console.log("error: " + error);
                });
              }

              db0.close();
              this.sync.section = null;
              this.sync.halt = false;
            }
          },
        },

        // --- MOUNTED ---
        mounted() {
          if ('coinbase' in localStorage) {
            this.coinbase = localStorage.coinbase;
          }
          // if ('selectedCollections' in localStorage) {
          //   this.selectedCollections = JSON.parse(localStorage.selectedCollections);
          //   console.log("mounted - selectedCollections: " + JSON.stringify(this.selectedCollections, null, 2));
          // }
          // if ('selectedMainTable' in localStorage) {
          //   this.selectedMainTable = JSON.parse(localStorage.selectedMainTable);
          // }
          if ('myNFTsSettings' in localStorage) {
            const tempSettings = JSON.parse(localStorage.myNFTsSettings);
            if ('version' in tempSettings && tempSettings.version == this.settings.version) {
              this.settings = tempSettings;
              if (this.settings.tokensTable.currentPage > 1) {
                this.settings.tokensTable.currentPage = 1;
              }
            }
          }
          (async() => {
            await this.loadNFTs();
          })();
        },
      })
    </script>
  </body>
</html>
